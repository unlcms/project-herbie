<?php

namespace Drupal\media_embed_view_mode_restrictions\Plugin\Filter;

use Drupal\Core\Entity\EntityTypeManagerInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
use Drupal\filter\Plugin\FilterBase;
use Drupal\filter\Plugin\FilterInterface;
use Drupal\media\Plugin\Filter\MediaEmbed;
use Symfony\Component\DependencyInjection\ContainerInterface;

/**
 * Decorates the MediaEmbed filter plugin provided by core's Media module.
 */
final class MediaEmbedDecorator extends FilterBase implements ContainerFactoryPluginInterface {

  /**
   * The decorated plugin instance.
   *
   * @var \Drupal\filter\Plugin\FilterInterface
   */
  private $decorated;

  /**
   * The entity type manager.
   *
   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
   */
  protected $entityTypeManager;

  /**
   * MediaEmbedDecorator constructor.
   *
   * @param array $configuration
   *   The plugin configuration.
   * @param string $plugin_id
   *   The plugin ID.
   * @param mixed $plugin_definition
   *   The plugin definition.
   * @param \Drupal\filter\Plugin\FilterInterface $decorated
   *   The decorated plugin instance.
   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
   *   The entity type manager.
   */
  public function __construct(array $configuration, $plugin_id, $plugin_definition, FilterInterface $decorated, EntityTypeManagerInterface $entity_type_manager) {
    parent::__construct($configuration, $plugin_id, $plugin_definition);
    $this->decorated = $decorated;
    $this->entityTypeManager = $entity_type_manager;
  }

  /**
   * {@inheritdoc}
   */
  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
    return new static(
      $configuration,
      $plugin_id,
      $plugin_definition,
      MediaEmbed::create($container, $configuration, $plugin_id, $plugin_definition),
      $container->get('entity_type.manager')
    );
  }

  /**
   * {@inheritdoc}
   */
  public function settingsForm(array $form, FormStateInterface $form_state) {
    $form = $this->decorated->settingsForm($form, $form_state);
    // Get media bundles from options list generated by core for for
    // allowed media types.
    $media_bundles = $form['allowed_media_types']['#options'];

    foreach ($media_bundles as $id => $bundle) {
      // Re states behavior, a detail element should be shown if 1) its
      // related bundle is allowed in allowed_media_types or 2) if no
      // bundles are designated in allowed_media_types (as all bundles are
      // then allowed).
      $form['bundle_view_modes'][$id] = [
        '#type' => 'details',
        '#title' => $this->t('Allowed view modes: @bundle', ['@bundle' => $bundle]),
        '#open' => FALSE,
        '#states' => [
          'visible' => [
            [
              ':input[name="filters[media_embed][settings][allowed_media_types][' . $id . ']"]' => ['checked' => TRUE],
            ],
            'xor',
            [
              '#edit-filters-media-embed-settings-allowed-media-types input' => ['checked' => FALSE],
            ],
          ],
        ],
      ];

      // Copy view mode and allowed view modes fields provided
      // by core and modify.
      $form['bundle_view_modes'][$id]['default_view_mode'] = $form['default_view_mode'];
      $form['bundle_view_modes'][$id]['default_view_mode']['#default_value'] = isset($this->settings['bundle_view_modes'][$id]['default_view_mode']) ? $this->settings['bundle_view_modes'][$id]['default_view_mode'] : '';
      $form['bundle_view_modes'][$id]['allowed_view_modes'] = $form['allowed_view_modes'];
      $form['bundle_view_modes'][$id]['allowed_view_modes']['#default_value'] = isset($this->settings['bundle_view_modes'][$id]['allowed_view_modes']) ? $this->settings['bundle_view_modes'][$id]['allowed_view_modes'] : [];
    }

    // Override core-provided 'default_view_mode' and 'allowed_view_modes'
    // fields and replace with hidden fields. This will maintain their
    // respective config through form submission and config save, even though
    // they are not seen by the user.
    $form['default_view_mode'] = [
      '#type' => 'hidden',
      '#value' => $this->settings['default_view_mode'],
    ];
    $form['allowed_view_modes'] = [
      '#type' => 'hidden',
      '#value' => $this->settings['allowed_view_modes'],
    ];

    return $form;
  }

  /**
   * {@inheritdoc}
   */
  public function process($text, $langcode) {
    return $this->decorated->process($text, $langcode);
  }

  /**
   * {@inheritdoc}
   */
  public function tips($long = FALSE) {
    return $this->decorated->tips($long);
  }

  /**
   * {@inheritdoc}
   */
  public function calculateDependencies() {
    // Don't add the media_embed_view_mode_restrictions module as a dependency
    // because the un-installation of this module will then cause the removal
    // of text formats that use Media Embed, along with their related editor
    // instances. The media_embed_view_mode_restrictions_uninstall() function
    // handles configuration issues on un-installation.
    $dependencies = [];

    // Create array of all unique view modes.
    $view_modes = [];
    foreach ($this->settings['bundle_view_modes'] as $item) {
      // Combine the view modes from both config parameters.
      $bundle_view_modes = $item['allowed_view_modes'] + [$item['default_view_mode']];
      $view_modes = array_merge($view_modes, $bundle_view_modes);
    }
    $view_modes = array_unique(array_values($view_modes));

    $dependencies += ['config' => []];
    $storage = $this->entityTypeManager->getStorage('entity_view_mode');
    foreach ($view_modes as $view_mode) {
      if ($entity_view_mode = $storage->load('media.' . $view_mode)) {
        $dependencies[$entity_view_mode->getConfigDependencyKey()][] = $entity_view_mode->getConfigDependencyName();
      }
    }

    return $dependencies;
  }

  /**
   * {@inheritdoc}
   */
  public function setConfiguration(array $configuration) {
    // Remove form submission data for bundles not listed
    // by 'allowed_media_types'. If no bundles are listed in
    // 'allowed_media_types', then all bundles are allowed and all
    // configuration should be saved.
    if (!empty($configuration['settings']['allowed_media_types'])
      && !empty($configuration['settings']['bundle_view_modes'])
      ) {
      $configuration['settings']['bundle_view_modes'] = array_intersect_key(
        $configuration['settings']['bundle_view_modes'],
        $configuration['settings']['allowed_media_types']
      );
    }
    parent::setConfiguration($configuration);
  }

}
